<!DOCTYPE html>
<html  lang="zh_CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
      <title>high_level_data_structures.b_tree</title>
    
      <link rel="stylesheet" href="../../_static/pygments.css">
      <link rel="stylesheet" href="../../_static/theme.css">
      <link rel="stylesheet" href="../../_static/romnnn_sphinx_press_theme.css">
      
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>

      <!-- sphinx script_files -->
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
        <script src="../../_static/translations.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>

      
      <script src="../../_static/theme-vendors.js"></script>
      <script src="../../_static/theme.js" defer></script>
    
  <link rel="index" title="索引" href="../../genindex.html" />
  <link rel="search" title="搜索" href="../../search.html" /> 
  </head>

  <body>
    <div id="app" class="theme-container" :class="pageClasses"><navbar @toggle-sidebar="toggleSidebar">
  <div class="home-link-container">
      <router-link to="../../index.html" class="home-link">
      
        <span class="site-name">TheAlgorithmsNotesInPython</span>
    </router-link>
  </div>

  <div class="links">
    <navlinks class="can-hide">



    </navlinks>
  </div>
</navbar>

      
      <div class="sidebar-mask" @click="toggleSidebar(false)">
      </div>
        <sidebar @toggle-sidebar="toggleSidebar">
          
          <navlinks>
            



            
          </navlinks><div id="searchbox" class="searchbox" role="search">
  <div class="caption"><span class="caption-text">搜索</span>
    <div class="searchformwrapper">
      <form autocomplete="off" class="search" action="../../search.html" method="get">
        <input type="text" name="q" autocomplete="off" />
        <input type="submit" value="转向" />
        <input type="hidden" name="check_keywords" value="yes" />
        <input type="hidden" name="area" value="default" />
      </form>
    </div>
  </div>
</div><div class="sidebar-links" role="navigation" aria-label="main navigation">
  
    <div class="sidebar-group">
      <p class="caption">
        <span class="caption-text"><a href="../../index.html#welcome-to-the-algorithms-in-python-s-documentation">Contents:</a></span>
      </p>
      <ul class="">
        
          <li class="toctree-l1 "><a href="../../rst/sort/modules.html" class="reference internal ">排序算法</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="../../rst/data_structures/modules.html" class="reference internal ">数据结构</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="../../rst/hashes/modules.html" class="reference internal ">哈希算法</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="../../rst/high_level_data_structures/modules.html" class="reference internal ">高级数据结构</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="../../rst/divide_and_conquer/modules.html" class="reference internal ">分治法</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="../../rst/greedy_algorithm/modules.html" class="reference internal ">贪心算法</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="../../rst/dynamic_programming/modules.html" class="reference internal ">动态规划</a>

            
          </li>

        
          <li class="toctree-l1 "><a href="../../rst/graphs/modules.html" class="reference internal ">图算法</a>

            
          </li>

        
      </ul>
    </div>
  
</div>
        </sidebar>

      <page>
          <div class="body-header" role="navigation" aria-label="navigation">
  
  <ul class="breadcrumbs">
    <li><a href="../../index.html">Docs</a> &raquo;</li>
    
      <li><a href="../index.html">模块代码</a> &raquo;</li>
    
    <li>high_level_data_structures.b_tree</li>
  </ul>
  

  <ul class="page-nav">
</ul>
  
</div>
<hr>
          <div class="content" role="main">
            
  <h1>high_level_data_structures.b_tree 源代码</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python3</span>
<span class="c1"># -*- coding:utf-8 -*-</span>
<span class="c1"># Author: Luo-Songtao</span>
<span class="c1"># Email: ryomawithlst@gmail/outlook.com</span>

<div class="viewcode-block" id="BTreeNode"><a class="viewcode-back" href="../../rst/high_level_data_structures/high_level_data_structures.html#high_level_data_structures.b_tree.BTreeNode">[文档]</a><span class="k">class</span> <span class="nc">BTreeNode</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;B树节点</span>
<span class="sd">    </span>
<span class="sd">    Attributes:</span>
<span class="sd">        leaf: 布尔类型值。为True则表示当前节点是叶节点</span>
<span class="sd">        keys_count: 记录当前节点上存储的关键字个数</span>
<span class="sd">        depth: 记录当前节点的高度</span>
<span class="sd">        keys: 存储当前节点存放的关键字</span>
<span class="sd">        child_nodes: 存储当前节点的子节点(指针)</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
<div class="viewcode-block" id="BTreeNode.__init__"><a class="viewcode-back" href="../../rst/high_level_data_structures/high_level_data_structures.html#high_level_data_structures.b_tree.BTreeNode.__init__">[文档]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">leaf</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">keys_count</span> <span class="o">=</span> <span class="mi">0</span>    <span class="c1"># 节点关键字个数</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">depth</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">keys</span> <span class="o">=</span> <span class="p">[]</span>    <span class="c1"># lenth = keys_count</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">child_nodes</span> <span class="o">=</span> <span class="p">[]</span>    <span class="c1"># length = keys_count + 1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="BTreeNode.get_key"><a class="viewcode-back" href="../../rst/high_level_data_structures/high_level_data_structures.html#high_level_data_structures.b_tree.BTreeNode.get_key">[文档]</a>    <span class="k">def</span> <span class="nf">get_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">[</span><span class="n">i</span><span class="p">]</span></div>
    
<div class="viewcode-block" id="BTreeNode.get_child_node"><a class="viewcode-back" href="../../rst/high_level_data_structures/high_level_data_structures.html#high_level_data_structures.b_tree.BTreeNode.get_child_node">[文档]</a>    <span class="k">def</span> <span class="nf">get_child_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">child_nodes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span></div>
    
<div class="viewcode-block" id="BTreeNode.pop_key"><a class="viewcode-back" href="../../rst/high_level_data_structures/high_level_data_structures.html#high_level_data_structures.b_tree.BTreeNode.pop_key">[文档]</a>    <span class="k">def</span> <span class="nf">pop_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="BTreeNode.pop_child_node"><a class="viewcode-back" href="../../rst/high_level_data_structures/high_level_data_structures.html#high_level_data_structures.b_tree.BTreeNode.pop_child_node">[文档]</a>    <span class="k">def</span> <span class="nf">pop_child_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">child_nodes</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="BTreeNode.insert_key"><a class="viewcode-back" href="../../rst/high_level_data_structures/high_level_data_structures.html#high_level_data_structures.b_tree.BTreeNode.insert_key">[文档]</a>    <span class="k">def</span> <span class="nf">insert_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">i</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span></div>

<div class="viewcode-block" id="BTreeNode.insert_child_node"><a class="viewcode-back" href="../../rst/high_level_data_structures/high_level_data_structures.html#high_level_data_structures.b_tree.BTreeNode.insert_child_node">[文档]</a>    <span class="k">def</span> <span class="nf">insert_child_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">i</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">child_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">child_nodes</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
        <span class="n">node</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span></div></div>

<div class="viewcode-block" id="BTree"><a class="viewcode-back" href="../../rst/high_level_data_structures/high_level_data_structures.html#high_level_data_structures.b_tree.BTree">[文档]</a><span class="k">class</span> <span class="nc">BTree</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;B树</span>
<span class="sd">    </span>
<span class="sd">    B树是为磁盘或其他直接存取的辅助存储设备而设计的一种平衡搜索树。B树类似于红黑树。但B树在降低磁盘I/O操作树方面更好一些。</span>
<span class="sd">    </span>
<span class="sd">    B树与红黑树的不同之处在于B树的节点可以有很多子节点，可以从数个到数千个。</span>
<span class="sd">    </span>
<span class="sd">    B树以一种自然方式推广了二叉搜索树：如果B树的一个节点拥有n个关键字，那么该节点就会有n+1个子节点</span>
<span class="sd">    </span>
<span class="sd">    **B树的性质**：</span>
<span class="sd">        1. 每个节点有以下属性：</span>
<span class="sd">            - keys_count，存储当前节点中关键字个数</span>
<span class="sd">            - keys_count个关键字，并以非降序存放</span>
<span class="sd">            - leaf，一个布尔值，当前节点是叶节点则为True，否则为False</span>
<span class="sd">        2. 每个内部节点还包含keys_count+1个指向其孩子的指针，但注意叶子节点没有子节点，所以它们不需维护这样的指针</span>
<span class="sd">        3. 节点上的关键字对存储在各个子树中的关键字的范围加以分割</span>
<span class="sd">        4. 每个叶节点具有相同的深度。即树的高度h</span>
<span class="sd">        5. 每个节点所包含的关键字个数有上界和下届。用一个被称为B树的**最小度数(minmum degree)**的固定整数来表示这些界</span>
<span class="sd">            - 除了根节点以外的每个节点必须至少有minmum_degree-1个关键字。因此除了根节点以外的每个内部节点至少有minmum_degree个子节点。如果树非空，则根节点至少又一个子节点。</span>
<span class="sd">            - 每个节点至多可拥有2minmum_degree-1个关键字。因此，一个内部节点至多有2minmum_degree个子节点。</span>
<span class="sd">            - 满节点：拥有2minmum_degree-1个关键字</span>
<span class="sd">        最小度数为2的B树是最简单的。同时t的值越大，B树的高度也就越小。</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
<div class="viewcode-block" id="BTree.__init__"><a class="viewcode-back" href="../../rst/high_level_data_structures/high_level_data_structures.html#high_level_data_structures.b_tree.BTree.__init__">[文档]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">:</span> <span class="n">BTreeNode</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">minmum_degree</span> <span class="o">=</span> <span class="kc">None</span></div>
    
<div class="viewcode-block" id="BTree.allocate_node"><a class="viewcode-back" href="../../rst/high_level_data_structures/high_level_data_structures.html#high_level_data_structures.b_tree.BTree.allocate_node">[文档]</a>    <span class="k">def</span> <span class="nf">allocate_node</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BTreeNode</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;模拟在O(1)的时间内为新节点分配一个磁盘页</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">BTreeNode</span><span class="p">()</span></div>

<div class="viewcode-block" id="BTree.disk_read"><a class="viewcode-back" href="../../rst/high_level_data_structures/high_level_data_structures.html#high_level_data_structures.b_tree.BTree.disk_read">[文档]</a>    <span class="k">def</span> <span class="nf">disk_read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;模拟数据读取磁盘I/O操作</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>
    
<div class="viewcode-block" id="BTree.disk_write"><a class="viewcode-back" href="../../rst/high_level_data_structures/high_level_data_structures.html#high_level_data_structures.b_tree.BTree.disk_write">[文档]</a>    <span class="k">def</span> <span class="nf">disk_write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;模拟数据写入磁盘I/O操作</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="BTree.search"><a class="viewcode-back" href="../../rst/high_level_data_structures/high_level_data_structures.html#high_level_data_structures.b_tree.BTree.search">[文档]</a>    <span class="k">def</span> <span class="nf">search</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;搜索具有指定key值的节点对象</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            (node, i): 含有值为key的节点对象以及该key在该节点的索引位置。如果没有查寻到则返回None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_search</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span></div>
    
    <span class="k">def</span> <span class="nf">_search</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">BTreeNode</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;在节点上进行线性搜索查找指定key对象</span>
<span class="sd">        </span>
<span class="sd">        如果没有则递归到对应的子节点，直到叶子节点也没有，将返回None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">keys_count</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">&gt;</span> <span class="n">node</span><span class="o">.</span><span class="n">get_key</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="n">node</span><span class="o">.</span><span class="n">get_key</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">leaf</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">node</span><span class="o">.</span><span class="n">keys_count</span><span class="p">:</span>
            <span class="n">child_node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">get_child_node</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">child_node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">get_child_node</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">disk_read</span><span class="p">(</span><span class="n">child_node</span><span class="p">)</span>    
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_search</span><span class="p">(</span><span class="n">child_node</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
    
<div class="viewcode-block" id="BTree.create"><a class="viewcode-back" href="../../rst/high_level_data_structures/high_level_data_structures.html#high_level_data_structures.b_tree.BTree.create">[文档]</a>    <span class="k">def</span> <span class="nf">create</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;创建一颗空的B树</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">allocate_node</span><span class="p">()</span>
        <span class="n">node</span><span class="o">.</span><span class="n">leaf</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">node</span><span class="o">.</span><span class="n">keys_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">disk_write</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">node</span></div>
    
<div class="viewcode-block" id="BTree.split_child"><a class="viewcode-back" href="../../rst/high_level_data_structures/high_level_data_structures.html#high_level_data_structures.b_tree.BTree.split_child">[文档]</a>    <span class="k">def</span> <span class="nf">split_child</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">BTreeNode</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;节点分裂</span>
<span class="sd">        </span>
<span class="sd">        分裂步骤:</span>
<span class="sd">            - 当node节点第i个子节点达到2*minmum_degree-1个关键词时，将要对其进行分裂，将第i个子节点的第i个关键词提到node中</span>
<span class="sd">            - 建立一个新节点，将第i个子节点的第(minmum_degree), ...,第(2*minmum_degree-1)的(minmum_degree-1)个关键词放入新节点中</span>
<span class="sd">            - 并把新节点作为node的第i+1个子节点</span>
<span class="sd">        </span>
<span class="sd">        注意: 如果node节点的第i个子节点关键字个数低于最小度数-1，这里将会抛出异常</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            node (BTreeNode): 将要分裂的节点的父节点</span>
<span class="sd">            i (int): 表明node节点的第i个子节点将要进行分裂。i=0,1,2,...</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">the_child</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">get_child_node</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">the_child</span><span class="o">.</span><span class="n">keys_count</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">minmum_degree</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;未达到分裂条件&quot;</span><span class="p">)</span>
        
        <span class="n">i_left_child</span> <span class="o">=</span> <span class="n">the_child</span>
        <span class="n">i_right_child</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">allocate_node</span><span class="p">()</span>
        <span class="n">i_right_child</span><span class="o">.</span><span class="n">leaf</span> <span class="o">=</span> <span class="n">i_left_child</span><span class="o">.</span><span class="n">leaf</span>
        <span class="n">i_right_child</span><span class="o">.</span><span class="n">keys_count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minmum_degree</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">i_right_child</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">node</span>
        
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i_right_child</span><span class="o">.</span><span class="n">keys_count</span><span class="p">):</span>    <span class="c1"># 把后半部分的key移到新的节点</span>
            <span class="n">i_right_child</span><span class="o">.</span><span class="n">insert_key</span><span class="p">(</span><span class="n">i_left_child</span><span class="o">.</span><span class="n">pop_key</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minmum_degree</span><span class="p">))</span>
            
        <span class="k">if</span> <span class="ow">not</span> <span class="n">i_left_child</span><span class="o">.</span><span class="n">leaf</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i_right_child</span><span class="o">.</span><span class="n">keys_count</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>    <span class="c1"># 把后半部分的子节点指针移到新节点</span>
                <span class="n">i_right_child</span><span class="o">.</span><span class="n">insert_child_node</span><span class="p">(</span><span class="n">i_left_child</span><span class="o">.</span><span class="n">pop_child_node</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minmum_degree</span><span class="p">))</span>
        
        <span class="n">node</span><span class="o">.</span><span class="n">insert_key</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i_left_child</span><span class="o">.</span><span class="n">pop_key</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minmum_degree</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">node</span><span class="o">.</span><span class="n">insert_child_node</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i_left_child</span><span class="o">.</span><span class="n">pop_child_node</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minmum_degree</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        
        <span class="n">node</span><span class="o">.</span><span class="n">keys_count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">i_left_child</span><span class="o">.</span><span class="n">keys_count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minmum_degree</span> <span class="o">-</span> <span class="mi">1</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">disk_write</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">disk_write</span><span class="p">(</span><span class="n">i_left_child</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">disk_write</span><span class="p">(</span><span class="n">i_right_child</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="BTree.insert"><a class="viewcode-back" href="../../rst/high_level_data_structures/high_level_data_structures.html#high_level_data_structures.b_tree.BTree.insert">[文档]</a>    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;插入关键字</span>
<span class="sd">        </span>
<span class="sd">        插入新关键字，最终是向叶子节点中进行插入，但是为了保证插入后每一个节点的关键字个数不超过2*minmum_degree-1个，那么需要从根节点开始，递归的向下进行判断。</span>
<span class="sd">        </span>
<span class="sd">        插入步骤:</span>
<span class="sd">            - 首先从根节点开始，先判断根节点是否已经达到2*minmum_degree-1个关键字,如果达到了，则需要先对根节点进行分裂</span>
<span class="sd">            - 否则将从根节点开始往下递归判断，在每一层当遇到当前节点已经满足2*minmum_degree-1个关键字的，都要先对该节点进行分裂</span>
<span class="sd">            - 最后直到叶节点后，不再递归，并将关键字插入到对应的叶节点上</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">keys_count</span> <span class="o">==</span> <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">minmum_degree</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">new_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">allocate_node</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">new_node</span>
            <span class="n">new_node</span><span class="o">.</span><span class="n">leaf</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">new_node</span><span class="o">.</span><span class="n">keys_count</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">new_node</span><span class="o">.</span><span class="n">insert_child_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">split_child</span><span class="p">(</span><span class="n">new_node</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_insert</span><span class="p">(</span><span class="n">new_node</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_insert</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span></div>
    
    <span class="k">def</span> <span class="nf">_insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">BTreeNode</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;insert函数的辅助函数，完成递归判断与最终插入关键字的操作</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">keys_count</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">leaf</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">key</span> <span class="o">&lt;</span> <span class="n">node</span><span class="o">.</span><span class="n">get_key</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
                <span class="n">i</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">node</span><span class="o">.</span><span class="n">insert_key</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
            <span class="n">node</span><span class="o">.</span><span class="n">keys_count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">key</span> <span class="o">&lt;</span> <span class="n">node</span><span class="o">.</span><span class="n">get_key</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
                <span class="n">i</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">the_child</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">get_child_node</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">disk_read</span><span class="p">(</span><span class="n">the_child</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">the_child</span><span class="o">.</span><span class="n">keys_count</span> <span class="o">==</span> <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">minmum_degree</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">split_child</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">key</span> <span class="o">&gt;</span> <span class="n">node</span><span class="o">.</span><span class="n">get_key</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
                    <span class="n">the_child</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">get_child_node</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_insert</span><span class="p">(</span><span class="n">the_child</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
    
<div class="viewcode-block" id="BTree.delete"><a class="viewcode-back" href="../../rst/high_level_data_structures/high_level_data_structures.html#high_level_data_structures.b_tree.BTree.delete">[文档]</a>    <span class="k">def</span> <span class="nf">delete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;删除指定的key</span>
<span class="sd">        </span>
<span class="sd">        删除具有指定的key后，需要保证每一个非根节点的关键字个数不低于minmum_degree-1个。</span>
<span class="sd">        </span>
<span class="sd">        删除时一方面不仅要沿树下降一次，同时为了保持B树的性质，有可能需要回溯到父节点进行调整。可以采取两种方案进行回溯：</span>
<span class="sd">            - 在每一个node上添加parent指针，然后再通过再parent节点上进行查找来确定在parent上node的指针位置</span>
<span class="sd">            - 每次需要回溯时，重新沿树下降一次，降到父节点</span>
<span class="sd">        </span>
<span class="sd">        删除需要的情况(删除要处理的情况比插入时要复杂)，假设要删除的key就在树中：</span>
<span class="sd">            - 确定key所在的节点是内部节点还是叶节点</span>
<span class="sd">                - 情况1：如果是叶节点，且叶节点的关键字数多于最小度数-1，那么直接在叶结点删除key</span>
<span class="sd">                - 情况2：如果是叶节点，且叶节点的关键字数等于最小度数-1，由于删除后不满足B树性质，因此需要做出调整：</span>
<span class="sd">                    - a. 首先找到该叶节点的兄弟前驱或兄弟后继节点，如果他们中任意一个的关键字数多于最小度数-1个，那么从该兄弟中剔除一个出来，上升到父节点，并且从父节点中的下降一个到当前的叶节点，然后就回到了情况1</span>
<span class="sd">                    - b. 如果该叶节点的兄弟前驱或兄弟后继节点的关键字数都是最小度数-1，那么此时就会发生节点合并。并且此时需要看父节点的关键字数</span>
<span class="sd">                        - a. 如果父节点的关键字数多于最小度数-1个，那么从父节点中下降一个k，然后将k与当前叶节点以及它的其中一个相邻兄弟节点合并，这样又回到情况1(此时新的合并节点关键字个数是2*最小度数-1)</span>
<span class="sd">                        - b. 如果父节点的关键字数等于最小度数-1，那么由于父节点此时不能下降一个k出来，因此就需要对父节点进行一次合并，然后才能回到情况2.a.a</span>
<span class="sd">                - 情况3：如果是内部节点，且关键字数多于最小度数-1，那么需要看当前key的子&quot;前驱&quot;和子&quot;后继&quot;</span>
<span class="sd">                    - a. 如果它们俩中其中一个的关键字数多于最小度数-1个，那么直接从中提取一个上来，替换key所在的位置即可</span>
<span class="sd">                    - b. 如果它们俩的关键字数都是最小度数-1个，那么就需要先合并它们俩；然后直接从它们的父节点中删除key，并修改相应的指针</span>
<span class="sd">                - 情况4：如果是内部节点，且关键字数等于最小度数-1，同样需要看当前key的子&quot;前驱&quot;和子&quot;后继&quot;</span>
<span class="sd">                    - a. 同情况3.a</span>
<span class="sd">                    - b. 如果它们俩的关键字数都是最小度数-1个，那么此时就只能对这个内部节点进行合并，然后再回到情况3.b来处理</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_delete</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span></div>
        
    <span class="k">def</span> <span class="nf">_delete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">BTreeNode</span><span class="p">,</span> <span class="n">pre_node</span><span class="p">,</span> <span class="n">succeed_node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            key:</span>
<span class="sd">            node: </span>
<span class="sd">            pre_node: node的前驱节点，且与node具有相同父节点</span>
<span class="sd">            succeed_node: node的后继节点，且与node具有相同父节点</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># 功能未全部完成</span>
        <span class="k">def</span> <span class="nf">find_index_lt_key</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">keys_count</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">key</span> <span class="o">&gt;</span> <span class="n">node</span><span class="o">.</span><span class="n">get_key</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
                    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="k">return</span> <span class="n">i</span>
        
        <span class="n">i</span> <span class="o">=</span> <span class="n">find_index_lt_key</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">leaf</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">!=</span> <span class="n">node</span><span class="o">.</span><span class="n">get_key</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Delete Error: the key &#39;</span><span class="si">{}</span><span class="s2">&#39; not found in trees&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">keys_count</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">minmum_degree</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">node</span><span class="o">.</span><span class="n">pop_key</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">pre_node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">pre_node</span><span class="o">.</span><span class="n">keys_count</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">minmum_degree</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">pre_k</span> <span class="o">=</span> <span class="n">pre_node</span><span class="o">.</span><span class="n">pop_key</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">p_i</span> <span class="o">=</span> <span class="n">find_index_lt_key</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span> <span class="n">pre_k</span><span class="p">)</span>
                    <span class="n">p_k</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">pop_key</span><span class="p">(</span><span class="n">p_i</span><span class="p">)</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">insert_key</span><span class="p">(</span><span class="n">pre_k</span><span class="p">,</span> <span class="n">p_i</span><span class="p">)</span>
                    
                    <span class="n">node</span><span class="o">.</span><span class="n">pop_key</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">insert_key</span><span class="p">(</span><span class="n">p_k</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">succeed_node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">succeed_node</span><span class="o">.</span><span class="n">keys_count</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">minmum_degree</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">succeed_k</span> <span class="o">=</span> <span class="n">succeed_node</span><span class="o">.</span><span class="n">pop_key</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">s_i</span> <span class="o">=</span> <span class="n">find_index_lt_key</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span> <span class="n">succeed_k</span><span class="p">)</span>
                    <span class="n">s_k</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">pop_key</span><span class="p">(</span><span class="n">s_i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">insert_key</span><span class="p">(</span><span class="n">s_k</span><span class="p">,</span> <span class="n">s_i</span><span class="p">)</span>
                    
                    <span class="n">node</span><span class="o">.</span><span class="n">pop_key</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">insert_key</span><span class="p">(</span><span class="n">s_k</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">pass</span>
        
        <span class="n">the_child</span><span class="p">,</span> <span class="n">pre_child</span><span class="p">,</span> <span class="n">succeed_child</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">node</span><span class="o">.</span><span class="n">keys_count</span><span class="p">:</span>
            <span class="n">the_child</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">get_child_node</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">pre_child</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">get_child_node</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">succeed_child</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">the_child</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">get_child_node</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">pre_child</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">succeed_child</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">get_child_node</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">the_child</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">get_child_node</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">pre_child</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">get_child_node</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">succeed_child</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">get_child_node</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span></div>
    
            
        
    
</pre></div>

          </div>
          <div class="page-nav">
            <div class="inner"><ul class="page-nav">
</ul><div class="footer" role="contentinfo">
      &#169; 版权所有 2020, luo-songtao.
    <br>
    Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.4.1 with <a href="https://github.com/romnnn/sphinx_press_theme">Press Theme</a>.
</div>
            </div>
          </div>
      </page>
    </div>
    
    
  </body>
</html>